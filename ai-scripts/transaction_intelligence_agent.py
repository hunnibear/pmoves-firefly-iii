#!/usr/bin/env python3
"""
Transaction Intelligence Agent - Phase 1 Implementation

Pydantic-based autonomous agent for transaction categorization, rule learning,
and anomaly detection. Integrates with existing LangExtract AI infrastructure.
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from enum import Enum

from pydantic import BaseModel, Field, validator
import httpx
import json

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class EventType(str, Enum):
    """Types of events the agent can process"""
    TRANSACTION_CREATED = "transaction_created"
    TRANSACTION_UPDATED = "transaction_updated"
    TRANSACTION_DELETED = "transaction_deleted"
    MANUAL_ANALYSIS = "manual_analysis"
    BULK_ANALYSIS = "bulk_analysis"


class ActionType(str, Enum):
    """Types of actions the agent can take"""
    CATEGORIZE_TRANSACTION = "categorize_transaction"
    CREATE_RULE = "create_rule"
    UPDATE_RULE = "update_rule"
    FLAG_ANOMALY = "flag_anomaly"
    UPDATE_TAG = "update_tag"
    SUGGEST_BUDGET = "suggest_budget"


class AnalysisType(str, Enum):
    """Types of analysis the agent can perform"""
    CATEGORIZATION = "categorization"
    ANOMALY_DETECTION = "anomaly"
    RULE_OPTIMIZATION = "rule_optimization"
    PATTERN_RECOGNITION = "pattern_recognition"


class TransactionData(BaseModel):
    """Transaction data model"""
    id: int
    description: str
    amount: float
    date: datetime
    source_account: Optional[str] = None
    destination_account: Optional[str] = None
    category: Optional[str] = None
    tags: List[str] = Field(default_factory=list)
    notes: Optional[str] = None
    currency_code: str = "USD"
    
    @validator('amount')
    def amount_must_be_non_zero(cls, v):
        if v == 0:
            raise ValueError('Amount cannot be zero')
        return v


class UserContext(BaseModel):
    """User context for personalized agent behavior"""
    user_id: int
    preferences: Dict[str, Any] = Field(default_factory=dict)
    rules: List[Dict[str, Any]] = Field(default_factory=list)
    categories: List[str] = Field(default_factory=list)
    spending_patterns: Dict[str, Any] = Field(default_factory=dict)


class EventData(BaseModel):
    """Event data received from Firefly III"""
    event_type: EventType
    transaction: Optional[TransactionData] = None
    event_data: Dict[str, Any] = Field(default_factory=dict)
    timestamp: datetime
    source: str = "firefly_webhook"
    user_context: Optional[UserContext] = None


class AgentAction(BaseModel):
    """Action to be taken by the agent"""
    type: ActionType
    data: Dict[str, Any]
    confidence: float = Field(ge=0.0, le=1.0)
    reason: str
    requires_approval: bool = False


class AgentInsight(BaseModel):
    """Insight generated by the agent"""
    type: str
    title: str
    description: str
    confidence: float = Field(ge=0.0, le=1.0)
    metadata: Dict[str, Any] = Field(default_factory=dict)


class AgentResponse(BaseModel):
    """Response from the agent after processing an event"""
    status: str = "success"
    actions: List[AgentAction] = Field(default_factory=list)
    insights: List[AgentInsight] = Field(default_factory=list)
    rule_suggestions: List[Dict[str, Any]] = Field(default_factory=list)
    processing_time_ms: Optional[int] = None
    error: Optional[str] = None


class TransactionIntelligenceAgent:
    """
    Main Transaction Intelligence Agent
    
    Handles real-time transaction analysis, categorization, and rule learning
    using AI-powered insights and pattern recognition.
    """
    
    def __init__(self, langextract_url: str = "http://localhost:8000", 
                 ollama_url: str = "http://ollama:11434"):
        self.langextract_url = langextract_url
        self.ollama_url = ollama_url
        self.session = httpx.AsyncClient(timeout=30.0)
        
        # Agent state and learning
        self.learning_data = {}
        self.rule_patterns = {}
        self.anomaly_thresholds = {}
        
        logger.info("Transaction Intelligence Agent initialized")
    
    async def process_event(self, event_data: Union[Dict[str, Any], EventData]) -> AgentResponse:
        """
        Main event processing method
        
        Args:
            event_data: Raw event data from Firefly III or EventData object
            
        Returns:
            AgentResponse with actions and insights
        """
        start_time = datetime.now()
        
        try:
            # Handle different input types
            if isinstance(event_data, EventData):
                event = event_data
                user_context = event.user_context or UserContext(user_id=1)
            else:
                # Parse and validate event data from dictionary
                event = EventData(**event_data['event'])
                user_context = UserContext(**event_data.get('user_context', {}))
            
            logger.info(f"Processing event: {event.event_type}")
            
            # Route to appropriate handler
            if event.event_type in [EventType.TRANSACTION_CREATED, EventType.TRANSACTION_UPDATED]:
                response = await self._handle_transaction_event(event, user_context)
            elif event.event_type == EventType.MANUAL_ANALYSIS:
                response = await self._handle_manual_analysis(event, user_context)
            else:
                response = AgentResponse(
                    status="skipped",
                    error=f"Unsupported event type: {event.event_type}"
                )
            
            # Calculate processing time
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            response.processing_time_ms = int(processing_time)
            
            logger.info(f"Event processed in {processing_time:.2f}ms")
            return response
            
        except Exception as e:
            logger.error(f"Error processing event: {str(e)}", exc_info=True)
            return AgentResponse(
                status="error",
                error=str(e)
            )
    
    async def _handle_transaction_event(self, event: EventData, 
                                      user_context: UserContext) -> AgentResponse:
        """Handle transaction creation/update events"""
        
        if not event.transaction:
            return AgentResponse(status="error", error="No transaction data provided")
        
        actions = []
        insights = []
        
        # 1. AI-powered categorization
        categorization_action = await self._categorize_transaction(
            event.transaction, user_context
        )
        if categorization_action:
            actions.append(categorization_action)
        
        # 2. Anomaly detection
        anomaly_insight = await self._detect_anomalies(
            event.transaction, user_context
        )
        if anomaly_insight:
            insights.append(anomaly_insight)
            
            # Create flag action if anomaly detected
            if anomaly_insight.confidence > 0.7:
                actions.append(AgentAction(
                    type=ActionType.FLAG_ANOMALY,
                    data={
                        "transaction_id": event.transaction.id,
                        "anomaly_type": anomaly_insight.type,
                        "details": anomaly_insight.description
                    },
                    confidence=anomaly_insight.confidence,
                    reason=f"Anomaly detected: {anomaly_insight.description}",
                    requires_approval=True
                ))
        
        # 3. Rule learning and optimization
        rule_suggestions = await self._optimize_rules(event.transaction, user_context)
        
        # 4. Pattern recognition insights
        pattern_insight = await self._recognize_patterns(event.transaction, user_context)
        if pattern_insight:
            insights.append(pattern_insight)
        
        return AgentResponse(
            actions=actions,
            insights=insights,
            rule_suggestions=rule_suggestions
        )
    
    async def _handle_manual_analysis(self, event: EventData, 
                                    user_context: UserContext) -> AgentResponse:
        """Handle manual analysis requests"""
        
        analysis_type = event.event_data.get('analysis_type')
        transaction_id = event.event_data.get('transaction_id')
        
        if not transaction_id:
            return AgentResponse(status="error", error="No transaction ID provided")
        
        # TODO: Fetch transaction data from Firefly III API
        # For now, create a placeholder
        transaction = TransactionData(
            id=transaction_id,
            description="Manual analysis transaction",
            amount=100.0,
            date=datetime.now()
        )
        
        actions = []
        insights = []
        
        if analysis_type == AnalysisType.CATEGORIZATION:
            action = await self._categorize_transaction(transaction, user_context)
            if action:
                actions.append(action)
                
        elif analysis_type == AnalysisType.ANOMALY_DETECTION:
            insight = await self._detect_anomalies(transaction, user_context)
            if insight:
                insights.append(insight)
                
        # Add more analysis types as needed
        
        return AgentResponse(actions=actions, insights=insights)
    
    async def _categorize_transaction(self, transaction: TransactionData, 
                                    user_context: UserContext) -> Optional[AgentAction]:
        """Use AI to categorize transaction"""
        
        try:
            # Prepare context for AI categorization
            context = {
                "description": transaction.description,
                "amount": transaction.amount,
                "existing_categories": user_context.categories,
                "user_rules": user_context.rules,
                "similar_transactions": await self._find_similar_transactions(transaction)
            }
            
            # Call LangExtract for AI categorization
            category_result = await self._call_langextract_categorization(context)
            
            if category_result and category_result.get('confidence', 0) > 0.6:
                return AgentAction(
                    type=ActionType.CATEGORIZE_TRANSACTION,
                    data={
                        "transaction_id": transaction.id,
                        "suggested_category": category_result['category'],
                        "reasoning": category_result.get('reasoning', ''),
                    },
                    confidence=category_result['confidence'],
                    reason=f"AI suggested category based on transaction analysis",
                    requires_approval=category_result['confidence'] < 0.8
                )
                
        except Exception as e:
            logger.error(f"Categorization failed: {str(e)}")
            
        return None
    
    async def _detect_anomalies(self, transaction: TransactionData, 
                              user_context: UserContext) -> Optional[AgentInsight]:
        """Detect anomalies in transaction patterns"""
        
        # Simple anomaly detection based on amount and patterns
        user_spending = user_context.spending_patterns
        
        # Check for unusually large amounts
        avg_amount = user_spending.get('average_amount', 100.0)
        if abs(transaction.amount) > avg_amount * 3:
            return AgentInsight(
                type="amount_anomaly",
                title="Unusual Transaction Amount",
                description=f"Transaction amount ({transaction.amount}) is significantly higher than usual ({avg_amount:.2f})",
                confidence=0.8,
                metadata={
                    "transaction_amount": transaction.amount,
                    "user_average": avg_amount,
                    "multiplier": abs(transaction.amount) / avg_amount
                }
            )
        
        # Check for unusual merchant/description patterns
        # TODO: Implement more sophisticated anomaly detection
        
        return None
    
    async def _optimize_rules(self, transaction: TransactionData, 
                            user_context: UserContext) -> List[Dict[str, Any]]:
        """Generate rule optimization suggestions"""
        
        suggestions = []
        
        # Analyze if this transaction could improve existing rules
        for rule in user_context.rules:
            # Simple rule optimization logic
            if self._transaction_matches_pattern(transaction, rule):
                suggestions.append({
                    "type": "rule_refinement",
                    "rule_id": rule.get('id'),
                    "suggestion": "Refine rule to better match similar transactions",
                    "confidence": 0.7
                })
        
        return suggestions
    
    async def _recognize_patterns(self, transaction: TransactionData, 
                                user_context: UserContext) -> Optional[AgentInsight]:
        """Recognize spending patterns and trends"""
        
        # TODO: Implement pattern recognition
        # This could include:
        # - Recurring transactions
        # - Seasonal spending patterns
        # - Budget trend analysis
        
        return None
    
    async def _find_similar_transactions(self, transaction: TransactionData) -> List[Dict[str, Any]]:
        """Find similar transactions for context"""
        
        # TODO: Implement similarity search
        # This would query Firefly III API for similar transactions
        return []
    
    async def _call_langextract_categorization(self, context: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Call LangExtract service for AI categorization"""
        
        try:
            # Prepare prompt for LangExtract
            prompt = f"""
            Analyze this financial transaction and suggest the most appropriate category:
            
            Description: {context['description']}
            Amount: ${context['amount']:.2f}
            
            Available categories: {', '.join(context['existing_categories']) if context['existing_categories'] else 'None defined'}
            
            Please provide:
            1. Suggested category (create new if needed)
            2. Confidence level (0.0-1.0)
            3. Brief reasoning
            
            Respond in JSON format.
            """
            
            response = await self.session.post(
                f"{self.langextract_url}/api/categorize",
                json={
                    "prompt": prompt,
                    "context": context
                }
            )
            
            if response.status_code == 200:
                return response.json()
                
        except Exception as e:
            logger.error(f"LangExtract categorization failed: {str(e)}")
            
        return None
    
    def _transaction_matches_pattern(self, transaction: TransactionData, 
                                   rule: Dict[str, Any]) -> bool:
        """Check if transaction matches a rule pattern"""
        
        # Simple pattern matching logic
        rule_description = rule.get('description_pattern', '').lower()
        transaction_desc = transaction.description.lower()
        
        return rule_description in transaction_desc
    
    async def close(self):
        """Clean up resources"""
        await self.session.aclose()


# Singleton instance for FastAPI integration
agent_instance = None

def get_agent() -> TransactionIntelligenceAgent:
    """Get or create agent instance"""
    global agent_instance
    if agent_instance is None:
        agent_instance = TransactionIntelligenceAgent()
    return agent_instance